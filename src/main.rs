use git2::{Commit, Oid, Repository, Revwalk};

use std::env;
use std::fs::{self, File};
use std::io::{self, Write};

mod conventional_commits;
use conventional_commits::{MsgDesc, parse_commit_msg};

struct CommitDesc {
    oid: Oid,
    msg: MsgDesc,
    author: Option<String>,
}

/// Markdown formatter for changelogs.
struct MdFormatter<'r> {
    file: &'r mut File,
    repo: &'r Repository, // TODO: Settings and configuration
    config: FormatConfig,
}

/// Formatting configuration.
struct FormatConfig {
    /// Whether to give credit to `changen` for generating.
    ///
    /// Simply adds a line to the header:
    /// ```
    /// > Generated by `changen`.
    /// ```
    add_credit: bool,
    /// Branch the changelog is generated from.
    ///
    /// Used for GitHub links.
    remote: String,
}

impl Default for FormatConfig {
    fn default() -> Self {
        Self {
            add_credit: true,
            remote: "origin".into(),
        }
    }
}

// TODO?: Move to a trait
impl<'r> MdFormatter<'r> {
    fn start_changelog(&mut self) -> io::Result<usize> {
        let mut n = self.file.write("# Changelog\n".as_bytes())?;

        if self.config.add_credit {
            // TODO: Add link
            n += self
                .file
                .write("\n> Generated by `changen`.\n".as_bytes())?;
        }

        Ok(n)
    }

    fn write_tag(&mut self, tag: &str) -> io::Result<usize> {
        // TODO?: Add link
        self.file.write(format!("\n## {}\n", tag).as_bytes())
    }

    // TODO?: Author
    fn write_commit(&mut self, commit: &CommitDesc) -> io::Result<usize> {
        let msg = commit
            .msg
            .msg()
            .chars()
            .take_while(|c| *c != '\n')
            .collect::<String>();
        let hash_short = format!("`{:.7}`", commit.oid);
        // HACK: Remote
        let hash_url = {
            let remote = self.repo.find_remote(&self.config.remote).unwrap();
            let url = remote.url().unwrap().strip_suffix(".git").unwrap();

            format!("{}/commit/{}", url, commit.oid)
        };
        let tag = match commit.msg.tag() {
            None => {
                return self
                    .file
                    .write(format!("- {msg} [{hash_short}]({hash_url})\n").as_bytes());
            }
            Some(tag) if tag == "chore" => return Ok(0),
            Some(tag) => format!("**{}** ", tag),
        };
        let scope = match commit.msg.scope() {
            None => "".into(),
            Some(scope) => format!("_{}_ ", scope),
        };
        let line = if commit.msg.is_breaking() {
            format!("- {tag}{scope}: <u>{msg}</u> [{hash_short}]({hash_url})\n")
        } else {
            format!("- {tag}{scope}: {msg} [{hash_short}]({hash_url})\n")
        };

        // HACK?
        self.file.write(line.as_bytes())
    }
}

// NOTE: Question-mark comments show where I'm confused about returned type
// safety (why is there a `Result`, can it be safely `.unwrap`ped, etc.)
fn main() -> io::Result<()> {
    let filename = env::args().skip(1).next().unwrap_or_else(|| {
        println!("warning: not output file was specified, using `CHANGELOG.md`");

        "CHANGELOG.md".into()
    });

    // HACK?
    let mut file = fs::File::create(filename)?;

    let repo = match Repository::open(".") {
        Ok(x) => x,
        Err(e) => {
            println!("error: failed to find repository");
            return Ok(());
        }
    };

    let mut fmt = MdFormatter {
        file: &mut file,
        repo: &repo,
        config: FormatConfig::default(),
    };

    let head = repo.head().expect("failed to determine HEAD");
    let latest_commit_oid = head.target().expect("failed to get latest commit");
    let mut tagged_commits = find_tagged_commits(&repo).unwrap(); // Result?
    let mut commits = repo.revwalk().unwrap(); // Result?

    commits.push(latest_commit_oid).unwrap(); // ?

    let commit_descriptions = commit_descriptions(commits, &repo);

    // commit_descriptions.sort_by_key(|commit| commit.msg.tag().unwrap_or("").to_string());

    fmt.start_changelog()?;

    commit_descriptions.into_iter().for_each(|commit| {
        match tagged_commits.last() {
            Some((tag_name, tagged_commit)) if tagged_commit.id() == commit.oid => {
                fmt.write_tag(tag_name.strip_prefix("refs/tags/").unwrap())
                    .unwrap();
                tagged_commits.pop();
            }
            _ => (),
        }

        fmt.write_commit(&commit);
    });

    Ok(())
}

fn find_tagged_commits(repo: &Repository) -> Result<Vec<(String, Commit)>, git2::Error> {
    let mut commits = vec![];

    repo.tag_foreach(|oid, name| {
        let commit = repo.find_commit(oid).unwrap();

        // HACK?
        commits.push((String::from_utf8(name.to_vec()).unwrap(), commit));

        true
    })
    .map(|_| commits)
}

fn commit_descriptions(commits: Revwalk, repo: &Repository) -> Vec<CommitDesc> {
    let mut descriptions = vec![];

    commits.for_each(|oid| {
        let commit_oid = oid.unwrap(); // safe?
        let commit = repo.find_commit(commit_oid).unwrap(); // safe?
        let msg_raw = commit.message().unwrap(); // safe?

        let msg = parse_commit_msg(msg_raw);
        let commit_desc = CommitDesc {
            oid: commit_oid,
            msg,
            author: commit.author().name().map(str::to_string),
        };

        descriptions.push(commit_desc);
    });

    descriptions
}
